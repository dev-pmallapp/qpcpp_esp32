//$file${include::qs_dummy.hpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpcpp.qm
// File:  ${include::qs_dummy.hpp}
//
// This code has been generated by QM 6.2.3 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// Copyright (c) 2005 Quantum Leaps, LLC
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for licensees
// interested in retaining the proprietary status of the generated code.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${include::qs_dummy.hpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#ifndef QS_DUMMY_HPP_
#define QS_DUMMY_HPP_

#ifdef Q_SPY
#error "Q_SPY must NOT be defined to include qs_dummy.hpp"
#endif

#define QS_INIT(arg_)                   (true)
#define QS_EXIT()                       static_cast<void>(0)
#define QS_DUMP()                       static_cast<void>(0)
#define QS_GLB_FILTER(rec_)             static_cast<void>(0)
#define QS_LOC_FILTER(qs_id_)           static_cast<void>(0)

#define QS_GET_BYTE(pByte_)             (0xFFFFU)
#define QS_GET_BLOCK(pSize_)            (nullptr)

#define QS_BEGIN_ID(rec_, qs_id_)       if (false) {
#define QS_END()                        }
#define QS_BEGIN_INCRIT(rec_, qs_id_)   if (false) {
#define QS_END_INCRIT()                 }

#define QS_I8(width_, data_)            static_cast<void>(0)
#define QS_U8(width_, data_)            static_cast<void>(0)
#define QS_I16(width_, data_)           static_cast<void>(0)
#define QS_U16(width_, data_)           static_cast<void>(0)
#define QS_I32(width_, data_)           static_cast<void>(0)
#define QS_U32(width_, data_)           static_cast<void>(0)
#define QS_F32(width_, data_)           static_cast<void>(0)
#define QS_F64(width_, data_)           static_cast<void>(0)
#define QS_I64(width_, data_)           static_cast<void>(0)
#define QS_U64(width_, data_)           static_cast<void>(0)
#define QS_ENUM(group_, value_)         static_cast<void>(0)
#define QS_STR(str_)                    static_cast<void>(0)
#define QS_MEM(mem_, size_)             static_cast<void>(0)
#define QS_SIG(sig_, obj_)              static_cast<void>(0)
#define QS_OBJ(obj_)                    static_cast<void>(0)
#define QS_FUN(fun_)                    static_cast<void>(0)

#define QS_SIG_DICTIONARY(sig_, obj_)   static_cast<void>(0)
#define QS_OBJ_DICTIONARY(obj_)         static_cast<void>(0)
#define QS_OBJ_ARR_DICTIONARY(obj_, idx_) static_cast<void>(0)
#define QS_FUN_DICTIONARY(fun_)         static_cast<void>(0)
#define QS_USR_DICTIONARY(rec_)         static_cast<void>(0)
#define QS_ENUM_DICTIONARY(value_, group_)  static_cast<void>(0)
#define QS_ASSERTION(module_, loc_, delay_) static_cast<void>(0)
#define QS_FLUSH()                      static_cast<void>(0)

#define QS_TEST_PROBE_DEF(fun_)
#define QS_TEST_PROBE(code_)
#define QS_TEST_PROBE_ID(id_, code_)
#define QS_TEST_PAUSE()                 static_cast<void>(0)

#define QS_OUTPUT()                     static_cast<void>(0)
#define QS_RX_INPUT()                   static_cast<void>(0)
#define QS_ONLY(code_)                  static_cast<void>(0)

//============================================================================
// interface used only for internal implementation, but not in applications
#ifdef QP_IMPL
    // predefined QS trace records
    #define QS_BEGIN_PRE_(rec_, qs_id_) if (false) {
    #define QS_END_PRE_()               }
    #define QS_BEGIN_PRE_(rec_, qs_id_) if (false) {
    #define QS_END_PRE_()        }
    #define QS_U8_PRE_(data_)           static_cast<void>(0)
    #define QS_2U8_PRE_(data1_, data2_) static_cast<void>(0)
    #define QS_U16_PRE_(data_)          static_cast<void>(0)
    #define QS_U32_PRE_(data_)          static_cast<void>(0)
    #define QS_TIME_PRE_()              static_cast<void>(0)
    #define QS_SIG_PRE_(sig_)           static_cast<void>(0)
    #define QS_EVS_PRE_(size_)          static_cast<void>(0)
    #define QS_OBJ_PRE_(obj_)           static_cast<void>(0)
    #define QS_FUN_PRE_(fun_)           static_cast<void>(0)
    #define QS_EQC_PRE_(ctr_)           static_cast<void>(0)
    #define QS_MPC_PRE_(ctr_)           static_cast<void>(0)
    #define QS_MPS_PRE_(size_)          static_cast<void>(0)
    #define QS_TEC_PRE_(ctr_)           static_cast<void>(0)

    #define QS_CRIT_STAT
    #define QS_CRIT_ENTRY()             static_cast<void>(0)
    #define QS_CRIT_EXIT()              static_cast<void>(0)

    #define QS_MEM_SYS()                static_cast<void>(0)
    #define QS_MEM_APP()                static_cast<void>(0)

    #define QS_TR_CRIT_ENTRY()          static_cast<void>(0)
    #define QS_TR_CRIT_EXIT()           static_cast<void>(0)
    #define QS_TR_ISR_ENTRY(isrnest_, prio_) static_cast<void>(0)
    #define QS_Tr_ISR_EXIT(isrnest_, prio_)  static_cast<void>(0)
#endif // QP_IMPL

#endif // QS_DUMMY_HPP_
